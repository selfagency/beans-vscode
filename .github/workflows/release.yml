name: Release

on:
  push:
    tags: ["v*"]
  workflow_dispatch:

permissions:
  contents: read
  actions: read

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

jobs:
  detect-tag:
    name: Detect release tag and readiness
    runs-on: ubuntu-latest
    timeout-minutes: 5

    outputs:
      release_tag: ${{ steps.tag.outputs.release_tag }}
      ready: ${{ steps.tag.outputs.ready }}

    steps:
      - name: Resolve tag from successful workflow runs
        id: tag
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tagName = context.ref.replace('refs/tags/', '');

            if (!tagName || !tagName.startsWith('v')) {
              core.info(`Ref '${context.ref}' is not a release tag; skipping.`);
              core.setOutput('release_tag', '');
              core.setOutput('ready', 'false');
              return;
            }

            const refData = await github.rest.git.getRef({
              owner,
              repo,
              ref: `tags/${tagName}`,
            });

            const refObj = refData.data.object;
            const taggedSha =
              refObj.type === 'tag'
                ? (await github.rest.git.getTag({ owner, repo, tag_sha: refObj.sha })).data.object.sha
                : refObj.sha;
            const main = await github.rest.repos.getBranch({ owner, repo, branch: 'main' });
            const mainSha = main.data.commit.sha;

            if (taggedSha !== mainSha) {
              core.setFailed(
                `Release blocked: tag ${tagName} points to ${taggedSha}, but latest main is ${mainSha}.`
              );
              return;
            }

            const requiredWorkflows = ['CI', 'Remote Compatibility Tests'];

            for (const workflowName of requiredWorkflows) {
              const workflowsResp = await github.rest.actions.listRepoWorkflows({
                owner,
                repo,
                per_page: 100,
              });

              const workflow = workflowsResp.data.workflows.find(w => w.name === workflowName);
              if (!workflow) {
                core.setFailed(`Release blocked: required workflow '${workflowName}' not found in repository.`);
                return;
              }

              const runsResp = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: workflow.id,
                branch: 'main',
                head_sha: mainSha,
                status: 'completed',
                per_page: 10,
              });

              const run = runsResp.data.workflow_runs[0];
              if (!run) {
                core.setFailed(
                  `Release blocked: required workflow '${workflowName}' has no completed run for ${mainSha}.`
                );
                return;
              }
              if (run.conclusion !== 'success') {
                core.setFailed(
                  `Release blocked: workflow '${workflowName}' concluded with '${run.conclusion}' on ${mainSha}.`
                );
                return;
              }
            }

            core.info(`Release tag detected: ${tagName} on latest main commit ${mainSha}; all checks passed.`);
            core.setOutput('release_tag', tagName);
            core.setOutput('ready', 'true');

  release:
    name: Build and Release
    needs: detect-tag
    if: needs.detect-tag.outputs.release_tag != '' && needs.detect-tag.outputs.ready == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.detect-tag.outputs.release_tag }}
          fetch-depth: 0

      - name: Generate release notes for changelog
        id: changelog_notes
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const currentTag = '${{ needs.detect-tag.outputs.release_tag }}';

            const tagsResp = await github.rest.repos.listTags({
              owner,
              repo,
              per_page: 100,
            });
            const tags = tagsResp.data;

            const index = tags.findIndex(tag => tag.name === currentTag);
            const previousTag =
              index >= 0
                ? (tags.slice(index + 1).find(tag => tag.name.startsWith('v'))?.name ?? '')
                : '';

            const notesResponse = await github.rest.repos.generateReleaseNotes({
              owner,
              repo,
              tag_name: currentTag,
              ...(previousTag ? { previous_tag_name: previousTag } : {}),
              target_commitish: 'main',
            });

            core.info(
              previousTag
                ? `Generated changelog notes from ${previousTag} to ${currentTag}.`
                : `Generated changelog notes for ${currentTag} (no previous tag found).`
            );

            core.setOutput('previous_tag', previousTag);
            core.setOutput('notes', notesResponse.data.body ?? '');

      - name: Checkout main for version and changelog update
        run: |
          git fetch origin main --depth=1
          git checkout -B main origin/main

      - name: Update package.json version and CHANGELOG.md
        env:
          RELEASE_TAG: ${{ needs.detect-tag.outputs.release_tag }}
          PREVIOUS_TAG: ${{ steps.changelog_notes.outputs.previous_tag }}
          RELEASE_NOTES: ${{ steps.changelog_notes.outputs.notes }}
        run: |
          TAG="${{ needs.detect-tag.outputs.release_tag }}"
          VERSION="${TAG#v}"
          
          # Update package.json version
          cat > /tmp/update-version.cjs <<'NODE'
          const fs = require('fs');
          const pkgPath = 'package.json';
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = process.env.VERSION;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
          NODE
          
          VERSION="$VERSION" node /tmp/update-version.cjs
          echo "package.json version updated to $(node -p "require('./package.json').version")"
          
          # Update CHANGELOG.md
          cat > /tmp/update-changelog.cjs <<'NODE'
          const fs = require('fs');

          const changelogPath = 'CHANGELOG.md';
          const releaseTag = (process.env.RELEASE_TAG || '').trim();
          const version = releaseTag.replace(/^v/, '');
          const previousTag = (process.env.PREVIOUS_TAG || '').trim();
          const date = new Date().toISOString().slice(0, 10);
          const heading = `## [${version}] - ${date}`;
          const sourceLine = previousTag
            ? `\n\n_Source: changes from ${previousTag} to ${releaseTag}._`
            : '';
          const notesRaw = (process.env.RELEASE_NOTES || '').trim();
          const notes = notesRaw || '- No notable changes.';
          const section = `\n${heading}\n\n${notes}${sourceLine}\n`;

          const original = fs.existsSync(changelogPath)
            ? fs.readFileSync(changelogPath, 'utf8')
            : '# Change Log\n\n## [Unreleased]\n';

          if (original.includes(heading)) {
            console.log('CHANGELOG already contains this release heading; skipping update.');
            process.exit(0);
          }

          const marker = '## [Unreleased]';
          const idx = original.indexOf(marker);
          const updated =
            idx >= 0
              ? `${original.slice(0, idx + marker.length)}\n${section}${original.slice(idx + marker.length)}`
              : `${original}\n${section}`;

          fs.writeFileSync(changelogPath, updated);
          console.log(`Updated ${changelogPath} with ${heading}`);
          NODE

          node /tmp/update-changelog.cjs

      - name: Commit version and changelog, then move tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          # Check if there are changes to commit
          if git diff --quiet -- package.json CHANGELOG.md; then
            echo "No version or changelog changes to commit."
            echo "SKIP_TAG_MOVE=true" >> $GITHUB_ENV
          else
            git add package.json CHANGELOG.md
            git commit -m "chore(release): update version and changelog for ${{ needs.detect-tag.outputs.release_tag }} [skip ci]"
            git push origin HEAD:main
            
            # Move the tag to the new commit
            NEW_SHA=$(git rev-parse HEAD)
            echo "Moving tag ${{ needs.detect-tag.outputs.release_tag }} to $NEW_SHA"
            git tag -f ${{ needs.detect-tag.outputs.release_tag }} HEAD
            git push origin ${{ needs.detect-tag.outputs.release_tag }} --force
            echo "TAG_MOVED=true" >> $GITHUB_ENV
          fi
      
      - name: Checkout updated tag for build
        run: |
          git fetch origin --tags
          git checkout ${{ needs.detect-tag.outputs.release_tag }}

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: "22"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build extension package
        run: pnpm run package

      - name: Package extension
        run: |
          pnpm dlx @vscode/vsce package --no-dependencies --out beans-vscode.vsix

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.detect-tag.outputs.release_tag }}
          body: ${{ steps.changelog_notes.outputs.notes }}
          files: "beans-vscode.vsix"
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish to VS Code Marketplace
        if: "!contains(needs.detect-tag.outputs.release_tag, '-')"
        run: pnpm dlx @vscode/vsce publish --packagePath beans-vscode.vsix -p ${{ secrets.VSCE_PAT }}
        env:
          VSCE_PAT: ${{ secrets.VSCE_PAT }}

      - name: Publish to Open VSX
        if: "!contains(needs.detect-tag.outputs.release_tag, '-')"
        run: |
          pnpm dlx ovsx publish beans-vscode.vsix -p ${{ secrets.OVSX_PAT }}
        env:
          OVSX_PAT: ${{ secrets.OVSX_PAT }}
