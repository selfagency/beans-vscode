#!/usr/bin/env zx

import { Octokit } from '@octokit/rest';
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import ora from 'ora';

$.verbose = false;

const ROOT = resolve(dirname(fileURLToPath(import.meta.url)), '..');
cd(ROOT);

// ---------------------------------------------------------------------------
// Argument validation
// ---------------------------------------------------------------------------

const version = argv._[0];
if (!version || !/^\d+\.\d+\.\d+(-[0-9A-Za-z.-]+)?$/.test(version)) {
  console.error('Usage: pnpm release <version>   (e.g. pnpm release 1.0.5)');
  process.exit(1);
}

const tag = `v${version}`;

// ---------------------------------------------------------------------------
// Rollback state
//   commitLocal  ‚Äî release commit exists locally but has not been pushed
//   commitPushed ‚Äî release commit has been pushed to origin/main
//   tagPushed    ‚Äî tag has been pushed but release workflow has not yet succeeded
//   releaseDone  ‚Äî release workflow succeeded; nothing to undo
// ---------------------------------------------------------------------------

let commitLocal = false;
let commitPushed = false;
let tagPushed = false;
let releaseDone = false;

async function rollback() {
  if (releaseDone) {return;}
  $.verbose = false;
  try {
    if (tagPushed) {
      console.log(`\n‚ö†Ô∏è  Release workflow failed or was interrupted. Deleting remote tag ${tag}...`);
      try {
        await $`git push origin --delete ${tag}`;
        await $`git tag -d ${tag}`;
        console.log(`‚Ü©Ô∏è  Tag ${tag} deleted from remote and local.`);
      } catch {
        console.error(`‚ùå Could not delete tag. Manually run:`);
        console.error(`   git push origin --delete ${tag} && git tag -d ${tag}`);
      }
    }
    if (commitPushed) {
      console.log('\n‚ö†Ô∏è  Reverting release commit on origin/main...');
      try {
        await $`git revert --no-edit HEAD`;
        await $`git push origin main`;
        console.log('‚Ü©Ô∏è  Release commit reverted and pushed. Working tree is clean.');
      } catch {
        console.error('‚ùå Automatic revert failed. Manually run:');
        console.error('   git revert HEAD && git push origin main');
      }
    } else if (commitLocal) {
      console.log('\n‚ö†Ô∏è  Release aborted before push. Resetting local release commit...');
      try {
        await $`git reset --hard HEAD~1`;
        console.log('‚Ü©Ô∏è  Local release commit removed. Working tree restored.');
      } catch {
        console.error('‚ùå Reset failed. Manually run: git reset --hard HEAD~1');
      }
    }
  } catch { /* best effort */ }
}

process.on('SIGINT', async () => { await rollback(); process.exit(130); });
process.on('SIGTERM', async () => { await rollback(); process.exit(143); });

// ---------------------------------------------------------------------------
// Main ‚Äî wrapped so any unhandled error triggers rollback
// ---------------------------------------------------------------------------

async function main() {
  // --- Prerequisites -------------------------------------------------------

  try {
    await $`which git`;
  } catch {
    console.error("‚ùå 'git' is required but not found in PATH.");
    process.exit(1);
  }

  // Resolve GitHub auth token: prefer env vars, then ask the gh CLI.
  let githubToken = process.env.GH_TOKEN ?? process.env.GITHUB_TOKEN ?? '';
  if (!githubToken) {
    try {
      githubToken = (await $`gh auth token`).stdout.trim();
    } catch {
      console.error('‚ùå No GitHub token found. Set GH_TOKEN/GITHUB_TOKEN or run: gh auth login');
      process.exit(1);
    }
  }

  const octokit = new Octokit({ auth: githubToken });

  // --- Precondition checks --------------------------------------------------

  const dirty = (await $`git status --porcelain`).stdout.trim();
  if (dirty) {
    console.error('‚ùå Working tree is not clean. Commit or stash changes first.');
    process.exit(1);
  }

  const branch = (await $`git rev-parse --abbrev-ref HEAD`).stdout.trim();
  if (branch !== 'main') {
    console.error(`‚ùå Must run from 'main'. Current branch: ${branch}`);
    process.exit(1);
  }

  console.log('üîÑ Fetching latest refs...');
  await $`git fetch origin main`;
  await $`git pull --ff-only origin main`;

  // Derive owner/repo from the git remote URL.
  const remoteUrl = (await $`git remote get-url origin`).stdout.trim();
  const repoMatch = remoteUrl.match(/[:/]([^/]+)\/([^/.]+?)(\.git)?$/);
  if (!repoMatch) {
    console.error(`‚ùå Cannot parse owner/repo from remote URL: ${remoteUrl}`);
    process.exit(1);
  }
  const [, owner, repo] = repoMatch;

  // Check for existing local tag.
  const localTag = (await $`git tag -l ${tag}`).stdout.trim();
  if (localTag) {
    console.error(`‚ùå Local tag ${tag} already exists.`);
    process.exit(1);
  }

  // Check for existing remote tag via the API.
  try {
    await octokit.git.getRef({ owner, repo, ref: `tags/${tag}` });
    console.error(`‚ùå Remote tag ${tag} already exists.`);
    process.exit(1);
  } catch (err) {
    if (err.status !== 404) {
      throw err;
    }
    // 404 = tag does not exist; that's what we want.
  }

  // --- Previous tag (for release notes diff) --------------------------------

  const tagsResp = await octokit.paginate(octokit.git.listMatchingRefs, {
    owner,
    repo,
    ref: 'tags/v',
    per_page: 100,
  });

  const previousTag = tagsResp
    .map((r) => r.ref.replace('refs/tags/', ''))
    .filter((t) => t !== tag)
    .sort((a, b) => {
      const parse = (v) => v.replace(/^v/, '').split('.').map(Number);
      const [aMaj, aMin, aPatch] = parse(a);
      const [bMaj, bMin, bPatch] = parse(b);
      return aMaj - bMaj || aMin - bMin || aPatch - bPatch;
    })
    .at(-1) ?? '';

  // --- Release notes --------------------------------------------------------

  console.log(`üìù Generating release notes for ${tag}...`);

  const notesResp = await octokit.repos.generateReleaseNotes({
    owner,
    repo,
    tag_name: tag,
    target_commitish: 'main',
    ...(previousTag ? { previous_tag_name: previousTag } : {}),
  });
  const releaseNotes = notesResp.data.body?.trim() || '- No notable changes.';

  // --- Update package.json --------------------------------------------------

  console.log(`üß© Updating package.json to ${version}...`);
  const pkgPath = resolve(ROOT, 'package.json');
  const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));
  pkg.version = version;
  writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');

  // --- Update CHANGELOG.md --------------------------------------------------

  console.log('üß© Updating CHANGELOG.md...');
  const changelogPath = resolve(ROOT, 'CHANGELOG.md');
  const date = new Date().toISOString().slice(0, 10);
  const heading = `## [${version}] - ${date}`;
  const sourceLine = previousTag ? `\n\n_Source: changes from ${previousTag} to ${tag}._` : '';
  const section = `\n${heading}\n\n${releaseNotes}${sourceLine}\n`;

  const original = existsSync(changelogPath)
    ? readFileSync(changelogPath, 'utf8')
    : '# Change Log\n\n## [Unreleased]\n';

  if (!original.includes(heading)) {
    const marker = '## [Unreleased]';
    const idx = original.indexOf(marker);
    const updated =
      idx >= 0
        ? `${original.slice(0, idx + marker.length)}\n${section}${original.slice(idx + marker.length)}`
        : `${original}\n${section}`;
    writeFileSync(changelogPath, updated);
  } else {
    console.log('‚ÑπÔ∏è  CHANGELOG already contains this release heading; skipping.');
  }

  // --- Commit + push --------------------------------------------------------

  const hasChanges = (await $`git diff --name-only -- package.json CHANGELOG.md`).stdout.trim();
  if (hasChanges) {
    console.log('üì¶ Committing release metadata changes...');
    await $`git add package.json CHANGELOG.md`;
    await $`git commit -m ${'chore(release): update version and changelog for ' + tag}`;
    commitLocal = true;
  } else {
    console.log('‚ÑπÔ∏è  No version/changelog changes detected; nothing to commit.');
  }

  console.log('üöÄ Pushing main...');
  await $`git push origin main`;
  commitPushed = true;
  commitLocal = false;

  const headSha = (await $`git rev-parse HEAD`).stdout.trim();

  // --- Wait for required workflows (sequential to avoid concurrent-spinner visual corruption) ------

  const shortSha = headSha.slice(0, 7);
  console.log(`üîé Waiting for required workflows on ${shortSha}...`);
  // Give GitHub a moment to register the push before we start polling.
  await sleep(10_000);

  const spinner = ora({ text: 'CI: queued' }).start();
  for (const name of ['CI', 'Remote Compatibility Tests']) {
    spinner.text = `${name}: queued`;
    spinner.start();
    await waitForWorkflow(octokit, name, owner, repo, headSha, spinner);
  }

  // --- Tag + publish --------------------------------------------------------

  console.log(`üè∑Ô∏è  Creating annotated tag ${tag} at ${headSha}...`);

  const tagMessage = [
    `Release ${tag}`,
    releaseNotes,
    previousTag ? `Source: changes from ${previousTag} to ${tag}.` : '',
    `Target commit: ${headSha}`,
  ]
    .filter(Boolean)
    .join('\n\n');

  await $`git tag -a ${tag} ${headSha} -m ${tagMessage}`;

  console.log(`üöÄ Pushing tag ${tag}...`);
  await $`git push origin ${tag}`;
  tagPushed = true;

  // --- Watch the release workflow ------------------------------------------

  spinner.text = 'Release: waiting for workflow to trigger...';
  spinner.start();
  await waitForWorkflow(octokit, 'Release', owner, repo, headSha, spinner, {
    autoDispatch: false,
    branch: null,
  });

  releaseDone = true;
  console.log(`‚úÖ Release complete: ${tag} ‚Üí ${headSha}`);
}

// ---------------------------------------------------------------------------
// Workflow polling
// ---------------------------------------------------------------------------

async function waitForWorkflow(
  octokit,
  name,
  owner,
  repo,
  headSha,
  spinner,
  { timeoutMs = 3_600_000, pollMs = 15_000, autoDispatch = true, branch = 'main' } = {},
) {
  // Resolve the workflow ID by name.
  const workflowsResp = await octokit.actions.listRepoWorkflows({ owner, repo, per_page: 100 });
  const workflow = workflowsResp.data.workflows.find((w) => w.name === name);
  if (!workflow) {
    spinner.fail(`${name}: workflow not found in ${owner}/${repo}`);
    throw new Error(`[${name}] workflow not found in ${owner}/${repo}`);
  }

  const deadline = Date.now() + timeoutMs;
  let triggered = false;
  // Track cancelled run IDs so we skip them on subsequent polls and don't
  // mistake them for the new run that was re-dispatched.
  const cancelledRunIds = new Set();

  while (Date.now() < deadline) {
    const runsResp = await octokit.actions.listWorkflowRuns({
      owner,
      repo,
      workflow_id: workflow.id,
      ...(branch ? { branch } : {}),
      head_sha: headSha,
      per_page: 10,
    });

    // Find the latest run that isn't one we already marked as cancelled.
    const run = runsResp.data.workflow_runs.find((r) => !cancelledRunIds.has(r.id));

    if (!run) {
      if (autoDispatch && !triggered) {
        spinner.text = `${name}: no run found ‚Äî triggering workflow_dispatch...`;
        await octokit.actions.createWorkflowDispatch({ owner, repo, workflow_id: workflow.id, ref: 'main' });
        triggered = true;
        spinner.text = `${name}: waiting for run to appear...`;
      } else {
        spinner.text = `${name}: waiting for run to appear...`;
      }
    } else if (run.status !== 'completed') {
      const elapsed = Math.round((Date.now() - new Date(run.created_at).getTime()) / 1000);
      spinner.text = `${name}: ${run.status} (${elapsed}s elapsed)`;
    } else if (run.conclusion === 'success') {
      spinner.succeed(`${name}: passed`);
      return;
    } else if (run.conclusion === 'cancelled') {
      // Cancelled runs are often caused by a concurrent push racing with CI startup.
      // Record this run so we skip it on future polls, then re-dispatch.
      cancelledRunIds.add(run.id);
      spinner.text = `${name}: run was cancelled ‚Äî re-dispatching...`;
      triggered = false;
    } else {
      spinner.fail(`${name}: ${run.conclusion}`);
      throw new Error(`[${name}] conclusion=${run.conclusion}\n   Run: ${run.html_url}`);
    }

    await sleep(pollMs);
  }

  spinner.fail(`${name}: timed out`);
  throw new Error(`[${name}] timed out after ${timeoutMs / 1000}s`);
}

// ---------------------------------------------------------------------------
// Entry point
// ---------------------------------------------------------------------------

main().catch(async (err) => {
  const msg = err?.message ?? String(err);
  // ProcessOutput errors from zx already printed the command output; only
  // print extra context for our own thrown errors.
  if (!(err instanceof ProcessOutput)) {
    console.error(`‚ùå ${msg}`);
  }
  await rollback();
  process.exit(err?.exitCode ?? 1);
});
